position.left=5
position.top=22
position.width=576
position.height=740
position.maximize=1
#position.tile=1

full.screen.hides.menu=1

#minimize.to.tray=1
split.vertical=1
output.horizontal.size=200
output.vertical.size=60
output.initial.hide=1
output.scroll=1
horizontal.scrollbar=1
#horizontal.scroll.width=10000
horizontal.scroll.width.tracking=1
output.horizontal.scrollbar=1
#output.horizontal.scroll.width=10000
#output.horizontal.scroll.width.tracking=0
output.scroll=1
error.select.line=1
#end.at.last.line=0
tabbar.visible=1
#tabbar.hide.one=1
#tabbar.multiline=1
toolbar.visible=1
toolbar.detachable=1
#toolbar.usestockicons=1
menubar.detachable=1
#undo.redo.lazy=1
#fileselector.width=800
#fileselector.height=600
fileselector.show.hidden=1
#magnification=-1
#output.magnification=-1
clear.before.execute=1
# Sizes and visibility in edit pane
line.margin.visible=1
line.margin.width=4
margin.width=16
#fold.margin.width=16
#fold.margin.colour=#FF0000
#fold.margin.highlight.colour=#0000FF
#blank.margin.left=4
#blank.margin.right=4
buffered.draw=1
two.phase.draw=1
use.palette=0

# Element styles
view.eol=1
control.char.symbol=.
caret.period=1000
view.whitespace=1
view.indentation.whitespace=1
view.indentation.guides=1
view.indentation.examine=3
highlight.indentation.guides=1
caret.fore=#00FF00
caret.additional.blinks=0
caret.width=3
caret.line.back=#F0F0FF
caret.line.back.alpha=25
#edge.column=200
edge.mode=1
edge.column=80
edge.colour=#006000
braces.check=1
braces.sloppy=1
selection.fore=#00FF00
# DADADA used as background because it yields standard silver C0C0C0
# on low colour displays and a reasonable light grey on higher bit depths

selection.alpha=60
selection.back=#ff0000
#selection.additional.fore=#FFFF00
#selection.additional.back=#000080
#selection.additional.alpha=20
selection.multiple=1
selection.additional.typing=1
virtual.space=1
#rectangular.selection.modifier=4
whitespace.fore=#FF0000
whitespace.back=#000000
error.marker.fore=#FF0000
error.marker.back=#000000
error.inline=1
error.select.line=1
bookmark.fore=#8080FF
bookmark.back=#000000
bookmark.alpha=50
find.mark=#0000FF

highlight.current.word=1
highlight.current.word.colour=#FF0000
highlight.current.word.by.style=1
#caret.policy.xslop
#caret.policy.width
#caret.policy.xstrict
#caret.policy.xeven
#caret.policy.xjumps

#caret.policy.yslop
#caret.policy.lines
#caret.policy.ystrict
#caret.policy.yeven
#caret.policy.yjumps

#visible.policy.strict
#visible.policy.slop
#visible.policy.lines

rectangular.selection.modifier=8
#2 (Ctrl), 4 (Alt) or 8 (Super)

# Scripting
ext.lua.startup.script=$(SciteUserHome)/SciTEStartup.lua
ext.lua.auto.reload=1
#ext.lua.reset=1

# Checking
are.you.sure=1
are.you.sure.for.build=1
save.all.for.build=1
#quit.on.close.last=1
save.on.timer=60
are.you.sure.on.reload=1
reload.preserves.undo=1
check.if.already.open=1
default.file.ext=.cxx
#source.default.extensions=.h|.cxx|.bat
title.full.path=1
#title.show.buffers=1
pathbar.visible=1
save.recent=1
save.session=1
save.position=1
save.find=1
session.bookmarks=1
session.folds=1
find.replace.regexp=1
find.replace.advanced=1
find.indicator=1
buffers=100
buffers.zorder.switching=0
open.dialog.in.file.directory=1
strip.trailing.spaces=1
ensure.final.line.end=1
ensure.consistent.line.ends=1
view.whitespace=1
view.indentation.whitespace=1
view.indentation.guides=1
view.indentation.examine=3
highlight.indentation.guides=1
view.eol=1
eol.mode=LF
eol.auto=0
line.margin.visible=1
#line.margin.width
toolbar.detachable=1
toolbar.usestockicons=1
pathbar.visible=1
undo.redo.lazy=0
#api.*.cxx=d:\api\w.api
#locale.properties=locale.de.properties
#translation.missing=***
read.only=0
#max.file.size=1

# Indentation
tabsize=4
indent.size=4
use.tabs=1
indent.auto=1
indent.automatic=1
indent.opening=1
indent.closing=1
#tab.indents=0
#backspace.unindents=0

# Wrapping of long lines
wrap=0
wrap.style=1
cache.layout=3
output.wrap=1
output.cache.layout=3
wrap.visual.flags=3
wrap.visual.flags.location=3
wrap.indent.mode=0
wrap.visual.startindent=4
wrap.aware.home.end.keys=0

# Folding
# enable folding, and show lines below when collapsed.
fold=1
fold.compact=1
fold.flags=16
fold.symbols=1
#fold.on.open=1
fold.comment=1
fold.preprocessor=1

# Find and Replace
# Internal search always available with recursive capability so use in preference to external tool
find.command=
# findstr is available on recent versions of Windows including 2000
#if PLAT_WIN
#	find.command=findstr /n /s $(find.what) $(find.files)
#find.input=$(find.what)
#if PLAT_GTK
#	find.command=grep --line-number "$(find.what)" $(find.files)
find.files=*.c *.cxx *.h
#find.in.files.close.on.find=0
#find.in.dot=1
#find.in.binary=1
#find.close.on.find=0
#find.replace.matchcase=1
#find.replace.escapes=1
#find.replace.regexp=1
#find.replace.regexp.posix=1
#find.replace.wrap=0
#find.replacewith.focus=0
#find.replace.advanced=1
#find.use.strip=1
#replace.use.strip=1
#strip.button.height=24

# Behaviour
eol.mode=LF
eol.auto=1
clear.before.execute=0
#vc.home.key=1
#wrap.aware.home.end.keys=1

autocompleteword.automatic=1
autocomplete.choose.single=0

caret.policy.xslop=1
caret.policy.width=20
caret.policy.xstrict=0
caret.policy.xeven=0
caret.policy.xjumps=0
caret.policy.yslop=1
caret.policy.lines=1
caret.policy.ystrict=1
caret.policy.yeven=1
caret.policy.yjumps=0
#visible.policy.strict=1
#visible.policy.slop=1
#visible.policy.lines=4
#time.commands=1
#caret.sticky=1
#properties.directory.enable=1

# Status Bar
statusbar.visible=1
statusbar.number=4
statusbar.text.1=li=$(LineNumber) co=$(ColumnNumber) $(OverType) ($(EOLMode)) $(FileAttr)
statusbar.text.2=$(BufferLength) chars in $(NbOfLines) lines. Sel: $(SelLength) chars.
statusbar.text.3=Now is: Date=$(CurrentDate) Time=$(CurrentTime)
statusbar.text.4=$(FileNameExt) : $(FileDate) - $(FileTime) | $(FileAttr)

command.print.*=a2ps "$(FileNameExt)"
command.scite.help=x-www-browser "file://$(SciteDefaultHome)/SciTEDoc.html"

open.suffix.*.pm=.pm

#abbreviations.filepattern	 Loads an abbreviations file for a particular language overriding the default abbreviations file. For example,
#abbreviations.*.c=$(SciteUserHome)/c_abbrev.properties
#api.filepattern	 Loads a set of API files for a particular language. If there is more than one API file then the file names are separated by ';'. API files contain a sorted list of identifiers and function prototypes, one per line. If there are multiple files then each file should end with a line end or the next file's first line will merge with the previous file's last line. The "Complete Symbol" command looks at the characters before the caret and displayed the subset of the API file starting with that string. When an opening brace is typed, the file is searched for the text preceding the caret and if a function prototype is found then it is displayed as a calltip. For example, the setting
#api.*.c=w.api
#could be used with a w.api file containing
#fclose(FILE* fileClose)
#FILE
#fopen(const char* szFileName, const char* szMode)
#fpos_t
#fread(void* buf, size_t size, size_t count, FILE* file)
#fseek(FILE* file, long lnOffset, int nOrigin)
#to provide autocompletion and calltips for some of the C file functions. It is best to use the full path to the API file as otherwise the current directory is used. See the Creating API files section for ways to create API files.

#autocomplete.choose.single	 When set to 1 and an autocompletion list is invoked and there is only one element in that list then that element is automatically chosen. This means that the matched element is inserted and the list is not displayed.
#autocomplete.lexer.ignorecase
#autocomplete.*.ignorecase	 When set to 1 the API file is searched in a case insensitive way to find elements for autocompletion lists. Otherwise matches only occur if case also matches. The * form is used if there is no lexer specific setting.
#autocomplete.lexer.start.characters
#autocomplete.*.start.characters	 If this setting is not empty, typing any of the characters will cause autocompletion to start. For example, if autocomplete.python.start.characters=. and the API file for Python contains "string.rjust" and "string.replace" then typing "string." will cause the autocompletion to display both identifiers. The * form is used if there is no lexer specific setting.
#autocomplete.lexer.fillups
#autocomplete.*.fillups	 If this setting is not empty, typing any of the characters will cause autocompletion to complete. For example, if autocomplete.python.fillups=( and the API file for Python contains "string.replace" then typing "string.r(" will cause "string.replace(" to be inserted. The * form is used if there is no lexer specific setting.
#autocompleteword.automatic	 If this setting is 1 then when typing a word, if only one word in the document starts with that string then an autocompletion list is displayed with that word so it can be chosen by pressing Tab.
#calltip.lexer.ignorecase
#calltip.*.ignorecase	 When set to 1 the API file is searched in a case insensitive way to find the function which will have its signature displayed as a calltip. The * form is used if there is no lexer specific setting.
#calltip.lexer.use.escapes
#calltip.*.use.escapes	 When set to 1 the API file may contain C style backslash escapes which are listed in the command line arguments section. The * form is used if there is no lexer specific setting.
#calltip.lexer.word.characters
#calltip.*.word.characters	 To determine the identifier to look up for calltips, a search is performed allowing the characters in this set to be included in the identifier. While the same setting can be used as for word.characters, sometimes additional characters may be allowed. For example, in Python, '.' is not normally considered part of a word when selecting text, but it is good to allow "string.replace" to show a calltip so calltip.python.word.characters=._$(chars.alpha) would be a reasonable setting. The * form is used if there is no lexer specific setting.
#calltip.lexer.parameters.start
#calltip.lexer.parameters.end
#calltip.lexer.parameters.separators
#calltip.*.parameters.start
#calltip.*.parameters.end
#calltip.*.parameters.separators	 Allows you to specify characters which start, end and separate parameters. For most common languages, it's usually left brace for start, right brace for end and comma or semicolon for separator. E.g. CSS has colon for start, space for separator and nothing for end. You can specify more characters for each property. The * form is used if there is no lexer specific setting.
#calltip.lexer.end.definition
#calltip.*.end.definition	 API files may contain explanatory text after each function definition. To display the explanation on a second line, set this property to the character used at the end of the definition part. For most languages, this is ')'. The * form is used if there is no lexer specific setting.
#xml.auto.close.tags	 For XML and HTML, setting this property to 1 will automatically insert the corresponding end tag when '>' is typed to end a start tag. Type "<td>" and the result will be "<td></td>" with the caret placed between the tags.
# Internationalisation
# Japanese input code page 932 and ShiftJIS character set 128
#code.page=65001
#character.set=128
# Unicode
#code.page=65001
#code.page=0
#character.set=0
# Required for Unicode to work on GTK+:
#LC_CTYPE=en_US.UTF-8

#output.code.page=65001
# Export
#export.keep.ext=1
export.html.wysiwyg=1
#export.html.tabs=1
#export.html.folding=1
export.html.styleused=1
#export.html.title.fullpath=1
#export.rtf.tabs=1
#export.rtf.font.face=Arial
#export.rtf.font.size=9
#export.rtf.tabsize=8
#export.rtf.wysiwyg=0
#export.tex.title.fullpath=1
# Magnification (added to default screen font size)
export.pdf.magnification=0
# Font: Courier, Helvetica or Times (Courier line-wraps)
export.pdf.font=Helvetica
# Page size (in points): width, height
# E.g. Letter 612,792; A4 595,842; maximum 14400,14400
export.pdf.pagesize=595,842
# Margins (in points): left, right, top, bottom
export.pdf.margins=72,72,72,72
export.xml.collapse.spaces=1
export.xml.collapse.lines=1

# Define values for use in the imported properties files
chars.alpha=abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ
chars.numeric=0123456789
chars.accented=äöåúüˇ¿‡¡·¬‚√„ƒ‰≈Â∆Ê«Á»Ë…È ÍÀÎÃÏÕÌŒÓœÔ–—Ò“Ú”Û‘Ù’ı÷ÿ¯Ÿ˘⁄˙€˚‹¸›˝ﬁ˛ﬂˆ
# This is a better set for Russian:
#chars.accented=¿‡¡·¬‚√„ƒ‰≈Â®∏∆Ê«Á»Ë…È ÍÀÎÃÏÕÌŒÓœÔ–—Ò“Ú”Û‘Ù’ı÷ˆ◊˜ÿ¯Ÿ˘⁄˙€˚‹¸›˝ﬁ˛ﬂˇ

# The open.filter setting is used in the file selector which has a menu of filters to apply
# to the types of files seen when opening.
# There is a limit (possibly 256 characters) to the length of a filter on Windows,
# so not all source extensions can be in this setting.
source.files=*.asm;*.c;*.cc;*.cpp;*.cxx;*.cs;*.h;*.hh;*.hxx;*.hpp;\
*.idl;*.odl;*.rc;*.rc2;*.dlg;*.def;\
*.vb;*.vbs;*.bas;*.frm;*.cls;*.ctl;\
*.java;*.js;*.py;*.pl;*.rb;*.cgi;*.lua;*.conf;\
make*;*.mak;\
*.tt2;\
*.txt;\
*.log;\
*.properties;*.html;*.xml;*.iface;*.bat;*.e

all.files=All Files (*)|*|Hidden Files (.*)|.*|
open.filter=\
All Source|$(source.files)|\
$(all.files)\
$(filter.ada)\
$(filter.conf)\
$(filter.asm)\
$(filter.asn1)\
$(filter.ave)\
$(filter.baan)\
$(filter.bash)\
$(filter.caml)\
$(filter.cmake)\
$(filter.cpp)\
#$(filter.ch)\
$(filter.css)\
$(filter.d)\
$(filter.eiffel)\
$(filter.erlang)\
$(filter.fortran)\
$(filter.gap)\
$(filter.idl)\
$(filter.inno)\
$(filter.java)\
$(filter.js)\
$(filter.kix)\
$(filter.lout)\
$(filter.lua)\
$(filter.matlab)\
$(filter.metapost)\
$(filter.mmixal)\
#$(filter.modula3)\
$(filter.nncrontab)\
$(filter.nsis)\
$(filter.opal)\
$(filter.pascal)\
$(filter.perl)\
$(filter.php)\
$(filter.pov)\
$(filter.powershell)\
$(filter.prg)\
$(filter.properties)\
$(filter.ps)\
$(filter.python)\
$(filter.r)\
$(filter.ruby)\
$(filter.sql)\
$(filter.specman)\
$(filter.tcl)\
$(filter.tex)\
$(filter.text)\
$(filter.txt2tags)\
$(filter.vb)\
$(filter.web)\
$(filter.yaml)\
$(filter.verilog)\
$(filter.vhdl)

save.filter=$(open.filter)

# Give symbolic names to the set of fonts used in the standard styles.
font.base=font:Terminus,size:18
font.small=font:Terminus,size:18
font.comment=font:Terminus,size:18
font.code.comment.box=$(font.comment)
font.code.comment.line=$(font.comment)
font.code.comment.doc=$(font.comment)
font.code.comment.nested=$(font.comment)
font.text=font:Terminus,size:18
font.text.comment=font:Terminus,size:18
font.embedded.base=font:Terminus,size:18
font.embedded.comment=font:Terminus,size:18
font.monospace=font:Terminus,size:18
font.vbs=font:Terminus,size:18

font.js=$(font.comment)

font.base=$(font.monospace)
font.small=$(font.monospace)
font.comment=$(font.monospace)
font.text=$(font.monospace)
font.text.comment=$(font.monospace)
font.embedded.base=$(font.monospace)
font.embedded.comment=$(font.monospace)
font.vbs=$(font.monospace)

# Give symbolic names to the set of colours used in the standard styles.
colour.code.comment.box=fore:#00FF00
colour.code.comment.line=fore:#00FF00
colour.code.comment.doc=fore:#00FF00
colour.code.comment.nested=fore:#00FF00
colour.text.comment=fore:#00FF00
colour.other.comment=fore:#00FF00
colour.embedded.comment=fore:#00FF00
colour.embedded.js=fore:#00FF00
colour.notused=fore:#00FF00,back:#000000

colour.number=fore:#00FF00
colour.keyword=fore:#00FF00
colour.string=fore:#00FF00
colour.char=fore:#00FF00
colour.operator=fore:#00A000
colour.preproc=fore:#00FF00
colour.error=fore:#00FF00

# Perl styles
# The perl styles are set to lots of different foreground and background colours as an
# aid to debugging SciTE's Perl lexer - not because this is a good way to display Perl.
style.perl.32=
# White space
style.perl.0=fore:#00ff00,$(font.base)
# Error
style.perl.1=$(colour.error)
# Comment
style.perl.2=$(colour.code.comment.box),$(font.code.comment.box)
# POD: = at beginning of line
style.perl.3=fore:#004000,back:#000000,$(font.text),eolfilled
# Number
style.perl.4=$(colour.number)
# Keyword
style.perl.5=$(colour.keyword),bold
# Double quoted string
style.perl.6=$(colour.string),$(font.monospace)
# Single quoted string
style.perl.7=$(colour.char),$(font.monospace)
# Symbols / Punctuation. Currently not used by LexPerl.
style.perl.8=$(colour.notused),$(font.notused)
# Preprocessor. Currently not used by LexPerl.
style.perl.9=$(colour.notused),$(font.notused)
# Operators
style.perl.10=$(colour.operator),bold
# Identifiers (functions, etc.)
style.perl.11=fore:#00FF00
# Scalars: $var
style.perl.12=fore:#00FF00
# Array: @var
style.perl.13=fore:#00FF00
# Hash: %var
style.perl.14=fore:#00FF00
# Symbol table: *var
style.perl.15=fore:#00FF00
# Regex: /re/ or m{re}
style.perl.17=fore:#00FF00
# Substitution: s/re/ore/
style.perl.18=fore:#00FF00
# Long Quote (qq, qr, qw, qx) -- obsolete: replaced by qq, qx, qr, qw
style.perl.19=fore:#00FF00
# Back Ticks
style.perl.20=fore:#00FF00
# Data Section: __DATA__ or __END__ at beginning of line
style.perl.21=fore:#00FF00,eolfilled
# Here-doc (delimiter)
style.perl.22=fore:#00FF00
# Here-doc (single quoted, q)
style.perl.23=fore:#00FF00,eolfilled,notbold
# Here-doc (double quoted, qq)
style.perl.24=fore:#00FF00,eolfilled,bold
# Here-doc (back ticks, qx)
style.perl.25=fore:#00FF00,eolfilled,italics
# Single quoted string, generic
style.perl.26=fore:#00FF00,$(font.monospace),notbold
# qq = Double quoted string
style.perl.27=$(style.perl.6)
# qx = Back ticks
style.perl.28=$(style.perl.20)
# qr = Regex
style.perl.29=$(style.perl.17)
# qw = Array
style.perl.30=$(style.perl.13)
# POD: verbatim paragraphs
style.perl.31=fore:#00FF00,$(font.monospace),eolfilled
# subroutine prototype
style.perl.40=$(style.perl.10),italics
# format identifier
style.perl.41=fore:#00FF00,bold
# format body
style.perl.42=fore:#00FF00,eolfilled
# Braces are only matched in operator style
braces.perl.style=10

# Bash styles
# The bash styles are set to lots of different foreground and background colours as an
# aid to debugging SciTE's Bash lexer - not because this is a good way to display Bash.
style.bash.32=
# White space
style.bash.0=fore:#00FF00,$(font.base)
# Error
style.bash.1=$(colour.error)
# Comment
style.bash.2=$(colour.code.comment.box),$(font.code.comment.box)
# Number
style.bash.3=$(colour.number)
# Keyword
style.bash.4=$(colour.keyword),bold
# Double quoted string
style.bash.5=$(colour.string),$(font.monospace)
# Single quoted string
style.bash.6=$(colour.char),$(font.monospace)
# Operators
style.bash.7=$(colour.operator),bold
# Identifiers (functions, etc.)
style.bash.8=fore:#00FF00
# Scalars: $var
style.bash.9=fore:#00FF00
# Parameter expansion: ${var}
style.bash.10=fore:#00FF00
# Back Ticks
style.bash.11=fore:#00FF00
# Here-doc (delimiter)
style.bash.12=fore:#00FF00
# Here-doc (single quoted, q)
style.bash.13=fore:#00FF00,eolfilled,notbold
# Braces are only matched in operator style
braces.bash.style=7

command.go.$(file.patterns.awk)=gawk -f $(FileNameExt)

command.go.$(file.patterns.perl)=perl -w $(FileNameExt)

command.compile.$(file.patterns.perl)=perl -c -w $(FileNameExt)
command.name.0.$(file.patterns.perl)=Lint
command.0.$(file.patterns.perl)=perl -MO=Lint,all $(FileNameExt)

command.name.1.$(file.patterns.perl)=Check Syntax
command.1.$(file.patterns.perl)=perl -cw $(FileNameExt)

command.name.2.$(file.patterns.perl)=Code Profiler
command.2.$(file.patterns.perl)=perl -d:DProf $(FileNameExt)

command.name.3.$(file.patterns.perl)=Profiler Parser
command.3.$(file.patterns.perl)=C:\Perl\bin\dprofpp.bat $(FileDir)\tmon.out

# Global default styles for all languages
# Default
style.*.32=$(font.base),fore:#00FF00,back:#000000
# Line number
style.*.33=fore:#00FF00,back:#000000,$(font.base)
# Brace highlight
style.*.34=fore:#00FF00,back:#000000,bold
# Brace incomplete highlight
style.*.35=fore:#00FF00,back:#000000,bold
# Control characters
style.*.36=fore:#00FF00,back:#000000
# Indentation guides
style.*.37=fore:#00FF00

# Define the Lexer menu,
# Each item contains three parts: menu string | file extension | key
# The only keys allowed currently are based on F-keys and alphabetic keys and look like
# [Ctrl+][Shift+][Fn|a] such as F12 or Ctrl+Shift+D.
# A '&' may be placed before a letter to be used as an accelerator. This does not work on GTK+.
menu.language=\
#FreeBasic|bas||\
Text|txt|Shift+F11|\
Ada|ads||\
#Apache Confi&g|conf||\
Assembler|asm||\
#ASN.1|asn1||\
#Avenue|ave||\
#Baan|bc||\
&Batch|bat||\
#Bullant|ant||\
&C / C++|c||\
#CMake|cmake||\
C&#|cs||\
#COBOL|cob||\
#Csound|orc||\
CSS|css||\
D|d||\
&Difference|diff||\
#&Eiffel|e||\
#Erlang|erl||\
&Errorlist|err||\
#FlagShip|prg||\
#Forth|forth||\
&Fortran|f90||\
#Gap|g||\
H&ypertext|html|F12|\
#&InnoSetup|iss||\
&Java|java||\
Java&Script|js||\
#&Kix|kix||\
Lisp|lisp||\
#Lot|lot||\
#Lout|lt||\
Lu&a|lua||\
Matlab|m.matlab||\
&Makefile|mak|Ctrl+Shift+F11|\
#MetaPost|mp||\
#MMIXAL|mms||\
#Modula-3|m3||\
#&nnCron crontab|tab||\
#NSIS|nsis||\
#Objective Caml|ml||\
#Octave|m.octave||\
#Opal|impl||\
Pascal|pas||\
Pe&rl|pl||\
P&HP|php||\
#P&LSQL|spec||\
#P&ostScript|ps||\
#P&OV-Ray SDL|pov||\
#PowerShell|ps1||\
#PowerPro|powerpro||\
&Properties|properties||\
Pytho&n|py||\
#R|R||\
#Reso&urce|rc||\
Ruby|rb||\
Shell|sh||\
S&QL|sql||\
#Specman|e||\
&TCL|tcl||\
TeX|tex||\
#&txt2tags|t2t||\
&VB|vb||\
VBScr&ipt|vbs||\
#Verilog|v||\
#VHDL|vhd||\
&XML|xml|Shift+F12|\
YAML|yaml||

# User defined key commands
user.shortcuts=\
Ctrl+Shift+V|IDM_PASTEANDDOWN|\
Ctrl+PageUp|IDM_PREVFILE|\
Ctrl+PageDown|IDM_NEXTFILE|\
KeypadPlus|IDM_EXPAND|\
KeypadMinus|IDM_BLOCK_COMMENT|

#user.context.menu=\
#||\
#Next File|IDM_NEXTFILE|\
#Prev File|IDM_PREVFILE|

# Import all the language specific properties files
#import abaqus
#import ada
import asm
#import asn1
#import au3
#import ave
#import baan
#import freebasic
#import blitzbasic
#import bullant
#import caml
import conf
#import cobol
import cpp
import cmake
#import csound
import css
#import d
#import eiffel
import erlang
import escript
#import flagship
#import forth
#import fortran
#import gap
import html
#import inno
#import kix
#import lisp
#import lot
#import lout
import lua
#import matlab
#import metapost
#import mmixal
#import modula3
#import nimrod
#import nncrontab
#import nsis
#import opal
import others
import pascal
import perl
#import pov
#import powerpro
#import powershell
#import ps
#import purebasic
#import python
#import r
#import rebol
#import ruby
#import scriptol
#import smalltalk
#import spice
import sql
#import specman
#import tacl
#import tal
#import tcl
#import txt2tags
#import tex
#import vb
import yaml
#import verilog
#import vhdl

